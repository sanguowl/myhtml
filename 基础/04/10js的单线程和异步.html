<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
<!-- 
 1.可能你会觉得单线程和异步会在一起？对，js是单线程的，但是由于它的宿主环境
 也就是Node服务器或者浏览器是多线程，它们通过事件驱动机制使得js实现了
 单线程异步！
 -->
 
 <!-- 2.JS是单线程语言，浏览器只分配了一个主线程给JS，而JS中可能有许多耗时任务，
  比如网络请求，定时器，事件监听，但是浏览器又是追求速度的，如果按照JS的单线程，
  每个任务都好好排队的话，那么要执行完这么多任务就需要很久，执行效率低，甚至导致
  页面假死。
  所以浏览器为这些耗时任务额外安排了子线程，这些子线程任务就是异步的-->
  
  <!-- 3.事件驱动机制：刚才也说了，浏览器给耗时任务提供了子线程，但是主线程要如何
   知道子线程执行完毕了呢？这就需要用到回调函数了，在每个耗时任务中都会设置一个回调函数，
   任务执行完毕(例如计时器计时完毕，ajax请求返回结果,事件监听到了)就会执行回调函数，
   然后把任务放到“任务队列”中等待主线程来提取任务执行
   也因为这样被称为事件(或者说任务)驱动机制-->
   
   <!-- 
	4.浏览器为异步任务单独开辟的线程可以统一理解为WebAPIs，
	上文中说到的任务队列就是callback queue，
	堆（heap）和栈（stack）共同组成了js主线程，
	函数的执行就是通过进栈和出栈实现的，
	比如有一个foo()函数，主线程把它推入栈中，在执行函数体时，发现还需要执行其他几个函数，所以又把这几个函数推入栈中，
	等到函数执行完，就让函数出栈。等到stack清空时，说明一个任务已经执行完了，
	这时就会从callback queue中寻找下一个人任务推入栈中（这个寻找的过程，叫做event loop，
	因为它总是循环的查找任务队列里是否还有任务）
	-->
	
	</head>
	<body>
		<script type="text/javascript">
			// 5.计时器的异步
			setTimeout(function(){
				console.log(1);
			},0);
			console.log(2);
			// 输出结果是2,1
			/* 即使计时器的时间为0，但是计时器被认为是耗时任务，会被浏览器提供一个子线程，但一提供子线程
			 计时器就已经计时完毕，然后放到任务队列中等待，如果任务队列为空，那就把该任务推入栈中，然后执行，
			 但是需要注意的是，刚开始的时候，栈中有console.log(2);语句，所以需要先执行该语句*/
			 
			 // 6.ajax的异步
			 // ajax请求内容的时候是异步的，当请求完成后，会触发请求完成的事件，
			 // 然后把回调函数放入callback queue，等到主线程执行该回调函数时还是单线程的。
			 
			 
			 // 7.当存在多个耗时任务时,按照进入任务队列的先后而执行
			 function two(){
				 console.log('love')
			 }
			 // one是two的前置函数,需要先执行one函数再执行two函数
			 function one(callback){
				 setTimeout(function(){
				 	callback();			 
				 },1000)
				 console.log('one')
			 }
			 one(two)
			 
			 
	 /* 
	 JS单线程异步的优点：相比于多线程语言，它不必耗费过多的系统开销，同时也不必把精力用于处理多线程管理，
	 相比于同步执行的语言，宿主环境的多线程和事件驱动机制又让它实现了异步，从而实现了非阻塞I/O
	 */
		</script>
	</body>
</html>
