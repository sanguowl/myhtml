## 1.直接插入排序
* 基本原理:通过构建有序序列(刚开始的序列长度为1),然后逐个扫描后续的元素,对后续的元素跟有序序列进行比较,首先跟有序序列最后一个元素比较,如果比较失败则继续跟再后面一个元素比较,如此反复直至完成序列排列
* 以一组数据{12，15，9，20，6，31，24} 为例
* 1.首先设定12为有序序列,然后跟15进行比较,比较失败所以不用替换位置
* 2.[12,15]为有序序列,跟9进行比较,比较成功，序列变为[12,9,15]，然后9再跟12比较,比较成功,最后为[9,12,15]
* 3.此时有序序列为[9,12,15]，跟20比较，比较失败
* 4.此时有序序列为[9,12,15,20]，跟6比较，变为[9,12,15,6,20] => [9,12,6,15,20] => [9,6,12,15,20] => [6,9,12,15,20]
* 5.如此反复，最后为[6,9,12,15,20,24,31]
---
* 性能分析:
* 时间复杂度: 
* 1. 顺序排序时，如[1,2,3,4],次数为1+1+1=3，n为4(元素个数),所以时间复杂度为 (n-1)/2  O(n)
* 2. 逆序排序时,如[4,3,2,1]，次数为1+2+3=6,所以时间复杂度为 n(n-1)/2  O(n^2)
* 3. 当原始序列杂乱无章的时候，平均时间复杂度为 O(n^2)
* 空间复杂度:
* 由于只有一个待比较元素,只有一个辅助空间,所以空间复杂度为1
* 稳定性:
* 直接插入排序是稳定的,不像希尔排序可能会把两个相同值的元素颠倒顺序
* [参考链接](https://blog.csdn.net/hlc246/article/details/81076183)

## 2.二分查找(折半查找)
* 二分查找要求`序列本身是有序的`。因此对于无序的序列，我们要先对其进行排序
* 二分查找的过程:
* 1. 首先设置三个索引，第一个索引在序列头部left，第二个索引在序列中部middle，第三个索引在序列尾部right
* 2. 然后待查找元素k跟索引middle所在元素进行比较，如果`大于middle所在元素，那么left=middle+1，middle=(left+right)/2,序列向右边前进`
* 3. 如果`小于middle所在的元素，那么right=middle-1,middle=(left+right)/2，序列向左前进`
* 4. 如果`等于middle所在的元素，说明查找成功`
* 5. 如果`查找一段时间之后,left>right,那么说明查找失败`
---
* 例子:在数组{2,4,5,7,8,9,13,22,34,45}中查找元素23  (要区分开索引和值)
* 1. left->2 ;middle->8(偶数则偏向左边取值);right->45
* 2.  23>middle(8),所以向右边移动,left=middle+1,left指向9;  middle=(left+right)/2=(5+9)/2=7 ;middle->22
* 3. 此时middle=22, 23>22 所以需要向右移动,left=middle+1=7+1=8,指向34; middle=(left+right)/2=8,也是指向34,,此时right=9
* 4. 此时middle=34 ,23<34,所以需要向左移动,right=middle-1=8,middle=(right+left)/2=8
* 5. middle不变,23<34,所以还需要向左移动,right=middle-1=7,此时right< left，所以查找失败!
---
* 根据例子得知，此时需要移动转向的时候都勉强可以认为查找失败了，但是设定left>right时查找失败更容易使用
* `如果二分查找(折半查找)成功会返回元素下标`
* [二分查找](https://www.cnblogs.com/QG-whz/p/5194627.html)

## 3.二分插入排序
* `使用二分插入排序的数组必须是有序的`
* `注意二分插入排序与二分查找不一样，二分插入排序是在left>right的时候(二分查找失败)才插入元素`
* 举个例子:在数组{2,4,5,7,8,9,13,22,34,45}中`插入`元素23  (要区分开索引和值)
* 1. left->2 ;middle->8(偶数则偏向左边取值);right->45
* 2.  23>middle(8),所以向右边移动,left=middle+1,left指向9;  middle=(left+right)/2=(5+9)/2=7 ;middle->22
* 3. 此时middle=22, 23>22 所以需要向右移动,left=middle+1=7+1=8,指向34; middle=(left+right)/2=8,也是指向34,,此时right=9
* 4. 此时middle=34 ,23<34,所以需要向左移动,right=middle-1=8,middle=(right+left)/2=8
* 5. 此时middle依旧为8, 23<34,所以需要向左移动,right=middle-1=7,指向22; 而此时left>right
* 6. left>right,所以left与right索引的中间位置可以插入23,插入之后为...9,`22`,23,`34`...
--- 
* 稳定性:与希尔排序不同,二分插入排序不会颠倒元素顺序，所以是有稳定性的
* 性能分析:
* 时间复杂度:`待完善!`
* 空间复杂度:仅需要一个辅助空间存储待插入元素,所以空间复杂度为O(1)
```
function truncate(arr,item) {
    // 二分插入排序
	var len=arr.length;
	var left=arr[0],right=arr[len-1],middle=arr[len/2];
	console.log(right)
	while(left<=right){
		// 右移
		if(item>middle){
			left=arr[arr.indexOf(middle)+1];//返回middle所在数组下标并加1
		}
		if(item<middle){
			right=arr[arr.indexOf(middle)-1];//返回middle所在数组下标并减1
		}
		middle=arr[(arr.indexOf(left)+arr.indexOf(right))/2];//重新计算middle索引
		// 更新一遍之后,再次计算left right
		if(left>right || left==arr[len-1]){
			// 在left,right中间创建一个位置,也就是right的前面，left的后面; right mm left
			arr.splice(arr.indexOf(right)+1,0,item);
			// arr.splice(下标,删除元素个数,插入元素值);//当删除元素个数为0时，并且设置了插入元素值那么就仅仅插入
			break;
		}
		// 在头部插入数据
		if(right==arr[0]){
			arr.unshift(item)
			break;
		}
	}
	return arr;
}
```

## 4.希尔排序
* 基本思想:假设待排序元素有n个，那么取一个整数(小于n)为increment,这个increment作为一个初始间隔，从初始元素开始，按照这个间隔跟对应元素归为一个序列进行比较(使用直接插入排序),然后间隔自减1缩小，重复子序列划分和元素比较工作，直至所有元素都被放到一个子序列为止
* 例子: `[21,25,49,25*,16,8]`  (25*指的是第二个值为25的数，两个数不一样的，但是值相同)
* 我们假设取increment的方法为 n/3 +1 =3, 也就是间隔为3
* 1. 21--25* ；25--16 ；49--8 ；子序列就这样列出来了，然后进行比较，=> 21--25*;16--25;8--49
* 2. 第一次排序后[21,16,8,25*,25,49],此时间隔increment-1,间隔为3-1=2，第二次子序列为 21--8--25 ; 16--25*--49;每个子序列分别进行直接插入排序,结果为 8--21--25 ;16--25*--49
* 3. 第二次排序后[8,16,21,25*,25,49]，此时间隔increment-1,间隔为2-1=1，所有的元素都在一个子序列了！所以排序结束
---
* 性能分析
* 时间复杂度: `待完善` 上面的例子:n=6, 第一次排列:1*3 , 第二次排列 2*2 ,排列次数为7
* 空间复杂度:因为只需要一个辅助空间存储待比较元素,所以空间复杂度为O(1)
* [希尔排列](https://blog.csdn.net/weixin_37818081/article/details/79202115)
