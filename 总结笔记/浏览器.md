## 1.浏览器页面由哪三层构成，分别是什么，作用是什么？
浏览器页面由结构层，表示层，行为层构成；分别是HTML,CSS,JavaScript；HTML的作用是实现页面结构，CSS的作用是实现页面的表现和风格，JavaScript的作用是进行客户端的功能，进行DOM操作
## 2.DOM的理解
DOM是文档对象模型(Document Object Model)的简称，是W3C国际标准组织推荐的可拓展标志语言(XML)的标准编程接口.在网页上，文档的对象被组织成树形结构，用来表示文档中的对象模型的就是DOM.
## 3.XML
XML（Extensible Markup Language）可拓展标记语言是W3C的推荐标准，虽然很像HTML语言，但是XML和HTML有以下不同。
* XML是用于数据的传输和存储的；HTML是用于显示数据的
* XML标签没有被预定义，需要自己定义；而HTML中使用的标签都是已经预定义过的
## 4.DOM解析XML的优缺点
1. 优点：
* 使用DOM的话，网页的文档会被组织成树形结构，利于理解，方便开发
* 在解析XML的过程中，树结构被存储在内存中，可以随时修改
2. 缺点：
* 由于是一次性读取文档，所以对内存的消耗有点大，所以才存在懒加载这种方式
* 由于XML文件过大，可能影响解析性能，可能出现内存溢出(注意：这里不是内存泄漏)
## 5.内存溢出，内存泄漏
1. 内存溢出是自己要求n大小的内存，但是超过了系统所能分配的内存，系统不能满足自身的需求，因此产生了溢出
2. 内存泄漏是JS中比较常见的错误，也算是没办法避免的，就是系统给变量分配了内存，但是变量已经没有被引用了，可是变量依旧不会被释放内存，有一点点内存泄漏是没问题的，但是多了的话，可分配的内存就会越来越少就会出现问题。
## 6.浏览器的重绘重排
  在浏览器下载完所有组件，html,css,js和图片之后，会解析生成两棵树，第一棵树是DOM树，第二棵树是渲染树
* 在文档初次加载的时候，浏览器引擎通过解析html文档构建一颗DOM树，之后按照DOM元素的几何属性构建一颗用于渲染的渲染树，渲染树中的节点也被称为盒子;可以理解为一个页面元素是一个具有内容，内填充，边框，外边距和位置的盒子
* 注意：由于在浏览器中设置了隐藏的元素不会显示(display:none不会占据位置,visibility:none虽然也隐藏但是会占据DOM位置,相当于透明度为0)，所以渲染树中并不会包含渲染元素(所以改变了隐藏样式为显示之后会有重排/重绘)
* 注意：对于使用流式布局的浏览器来说，对渲染树的计算只需要遍历一次就可以完成;但是table及其内部元素除外，需要多次计算才能确定其在渲染树中的属性，所以一般不用table布局
---
1. 重绘(`repaint`)：
  相当于元素的外观变化所触发的浏览器行为，例如改变color,background-clor,outline, 浏览器会根据元素的新属性进行重新绘制，让元素呈现新的外观，
     记住：重绘不会带来新的布局，只是改变布局内的元素外观
2. 重排(`reflow:所以也叫回流`)：
  当DOM事件导致元素的宽高位置改变的时候，浏览器需要重新计算该元素的几何属性和其他元素的几何属性，并且位置也可能会随之改变，例如float:left变为float:right。当发生重排，浏览器会使渲染树中受影响的部分暂时失效，然后重新构造渲染树
 ` 注意：重排一定伴随着重绘，重绘不一定会导致重排`
 
3. 触发重排的操作:
  * 改变元素的大小，位置，内容(内容一般只伴随着重绘，但是例如往p元素中填充一大堆文字，然后超过了父元素本来的大小，那么父元素的大小就会被撑开，导致重排)
  * 元素节点的增删，移动操作也会导致重排例如往第一个li元素前面添加一个li元素，那么后面所有的li元素以及之后的渲染树部分都要重排,但是往最后一个li元素后面添加一个li元素，就没有li元素需要重排，之后最后一个li元素之后的渲染树需要重排
  
## 7.浏览器存储
* IndexdDB 是 HTML5 的本地存储，把一些数据存储到浏览器（客户端）中，当与网络断开时，可以从浏览器中读取数据，用来做一些离线应用。
* Cookie 通过在客户端 ( 浏览器 ) 记录信息确定用户身份，最大为 4 kb ，在浏览器请求中每次都会附加在请求头中发送给服务器(`注意，cookie不设置过期时间的话，那么默认退出浏览器之后cookie就过期了`)
* SessionStorage 仅当前页面有效一旦关闭就会被释放。也不会随浏览器发送给服务器。大小5M或更大
* localStorage 也是 HTML5 的本地存储，将数据保存在客户端中（一般是永久的）。

## 8.cookie与session
* cookie是客户端使用的记录客户信息状态的机制
* Session是服务器端使用的一种记录客户端状态的机制(与浏览器的sessionStorage存储区分开来)

## 9.防抖节流
* 防抖和节流其实都是防止函数多次调用，`防抖是在除了第一次点击，之后的点击想要生效，必须由一定的间隔时间，也就是快速点无数下，结果也只有一下被响应`
* `而节流则是在一定的时间间隔内,点击一次或者多次都只识别一次，但是和防抖不同的是，假设间隔为1秒，则在3秒内一直连续点击，防抖只会响应一次，而节流会响应三次，因为每一秒都会响应一次`

## 10.页面的性能指标详解：
* 先触发白屏时间(first paint time)再触发可交互时间(dom ready)
1. 白屏时间(first paint time)用户从一开始打开页面到页面`开始有东西出现`，一般认为浏览器解析完"head"标签或者开始解析body标签就是白屏时间结束
2. 首屏时间是`用户看到的第一屏`，也即是网页顶部大小为当前窗口的区域显示完整的时间。首屏时间是衡量用户体验的一个重要因素，一般首屏时间应该在5秒以内
3. 用户可操作时间(user interactive)指的是用户可以进行正常的点击，滚动事件的时间，默认可以统计可交互时间(dom ready)
4. 总下载时间:页面所有资源都加载完并呈现出来的的时间,也就是onload时间

[参考链接](https://blog.csdn.net/qq_41047322/article/details/82814396)

## 11.script标签位置
1. head部分的脚本:把脚本放在head部分，可以保证脚本在任何调用之前就被加载了
2. body部分的脚本:当页面被加载的时候，脚本就被放在script标签所在的位置，放在body部分的脚本通常被用来生成页面内容
3. 如果把js放在head标签中先解析，那么此时body标签还没有被解析
4. 从性能的角度看，把脚本放在head标签中，脚本会阻塞其他资源的下载和页面渲染，这样用户就没办法快点看到页面，白屏时间就很长，所以我们应该把标签放在body标签底部，以尽量减少页面下载的影响

## 12.AMD(asynchronous modules definition)规范诞生
* `为什么会诞生模块呢?`2009年出现了node.js，将js用于服务器端编程，在以前的话，js都是用于浏览器端编程，对于浏览器端编程，没有模块也没有问题，因为浏览器端的程序一般都不是很复杂。
* 但是node.js让js开辟了服务器端领域，js想在服务器端编程就必须要有模块，与操作系统和其他应用程序交互，否则很难编程
* 看一个例子
```
var math=require('math')
math.add(2,3);//5
```
* 对于服务器端来说，所有的模块都存在本地硬盘中，可以同步加载完成，模块加载时间其实就是读取时间；但是对于浏览器端来说，模块都存放在服务端，所以模块加载时间就取决于网速了，可能要等很久，所以浏览器就相当于存于"假死状态"
`所以浏览器端的模块不能和服务器端的模块一样使用commonjs规范，因为commonjs规范是同步加载，而浏览器端的等待时间取决于网速，所以不能使用同步加载一直等待加载完毕，应该使用异步加载，这也是AMD规范诞生的背景`

## 13.AMD(asynchronous modles definition)规范
* AMD规范是Require.js在推广过程中对模块化定义的规范化产出，就是一个概念。
* Require.js是一个AMD框架，可以`异步加载`js文件，通过define()函数定义，第一个参数是数组['依赖的包']，第二个参数是回调函数，最后通过return来输出

## 14.CMD(common modules definition)规范
* CMD是SEA.js在推广过程中对模块定义的规范化产出
* CMD是一个同步模块，而SEA.js是淘宝团队提供的模块化开发的js框架
* 也是通过define()定义，通过require加载jq插件，CMD是依赖就近，在哪里使用插件就在哪里require,即用即返，这也是同步的概念

## 15.commonjs规范
* commonjs规范是通过module.exports定义的，`在前端浏览器中不支持`！
* module.exports是通过node.js服务器端使用的，`node.js使用的是common.js规范`;`而前端浏览器一般使用AMD,CMD,ES6等规范开发的`

## 16.ES6规范
* ES6规范是通过import/export对模块进行导入的
[参考](https://www.cnblogs.com/littlebirdlbw/p/5670633.html)
['参考'](https://blog.csdn.net/tangxiujiang/article/details/81104174)

## 17.web性能优化
1. 减少http请求数
2. 压缩外部文件，减少体积
3. 把script文件放到body标签底部(放在head标签中会导致页面先加载该文件再继续解析Body标签的内容，导致页面白屏时间长)，以免影响页面加载速度，用户体验不好
4. 合并图片从而减少请求数
5. css外部文件必须放在head标签中，否则放在body标签中，可能还没有下载完或者解析css文件，浏览器就根据body标签内容开始渲染页面构建DOM树了，但是样式还没有解析完成就会导致用户体验极差
6. 重绘跟重排应该尽量减少，特别是重排会让浏览器重新计算各个元素的位置，大小更加消耗资源，而重绘仅仅影响到自己那个元素
7. 减少不必要的DOM操作

## 18.web安全
* 客户端脚本安全
1. 跨站脚本攻击(XSS)
* XSS攻击指的是黑客通过"html注入"的方式篡改了网页，插入了恶意的脚本，从而在用户浏览网页的时候，控制用户浏览器的手段
* 最常见的XSS攻击是通过读取浏览器cookie对象，从而发起"cookie挟持"，当前用户的登录凭证保存在浏览器的session，客户端浏览器的cookie中,而浏览器的cookie被挟持之后，意味着黑客可以不通过密码直接登录系统
* 防御:`在cookie劫持这种XSS攻击中，可以用在cookie字段中加入httponly 来防止js获取cookie`
* 或者对`<>[]这种特殊的字符进行输入检查` 
2. CSRF(cross site request forgery跨站请求伪造)攻击及防御
*  首先用户访问网站a,输入账号和密码，服务器校验后返回set-cookie字段给用户浏览器
*  用户把数据存储在cookie字段中，然后用户在同一浏览器中访问网站b
*  `此时用户a还没有退出网站a`，然后网站b被用户访问之后，除了返回正常的代码，还返回了`攻击性的代码`
*  浏览器在接收到网站b发送的攻击性代码后，按照代码里面的请求去对网站a发起请求，此时的浏览器还带有cookie信息，然后网站b的攻击性代码就带着cookie向网站a发起了请求，而网站a看到cookie就不会怀疑，所以网站b可以获取到用户该有的权限，可以窃取资料或者进行转账等要求
*  防御:1.验证referer字段(该字段是记录发起请求的前一个页面地址的，而origin是最初的页面地址)；2.使用token验证，黑客可以获取到cookie，但是我们可以在http参数中加入token，然后在服务器中加入一个拦截器来验证；

* 服务器端应用安全
* 服务器端的安全比起客户端更加重要，因为服务器端的某个安全漏洞导致的是所有使用它的客户端都有安全漏洞
1. SQL注入攻击
* SQL注入攻击有两个关键条件:1. 用户能够控制输入 2. 原本程序要执行的代码，拼接了用户的输入的数据
* 防御手段
1.1 使用预编译语句，这是防止SQL注入最有效的方法，可以完全避免程序代码拼接带来的风险(这也是我们不使用eval()的原因)
1.2 关闭web服务器的错误回显功能，避免`便利了黑客改正错误的方便性`

## 打开Chrome的任务管理器查看进程
* 点击 Chrome 浏览器右上角的“选项”菜单，选择"更多工具"，点击任务管理器，打开窗口查看进程
* `可以看到，只打开了一个页面，却启动了4个进程(分别是GPU进程，network service网络进程，浏览器进程，网站进程)`

## 进程
* 一个进程其实就是一个程序的运行实例。启动一个程序的时候，操作系统会`为该程序创建一块内存，用来存放代码，运行中的数据和一个执行任务的主线程`。
* 线程不能单独存在的，线程是由进程来管理的
* 线程是依附在进程之上的，而进程中使用多线程并行处理可以提高运算效率

## 并行处理
* 举个例子
```
 a=7*8
 b=8-7
 c=66-2
```
* 在单线程中，该任务分四步，前三步是计算，最后一步是显示结果
* 而在多线程中，一个线程执行一个运算式子，所以只需要分两步，三个线程都执行完运算之后，最后显示出来

## 进程与线程之间的关系
1. 进程中的任一线程执行出错都会导致整个进程的崩溃(例如出了bug就报错不执行了)
2. 线程之间共享进程中的数据(例如刚才的并行处理例子，线程1，2，3可以分别对进程中的数据a,b,c进行写操作，最后由线程1/2/3来读取进程中的a,b,c数据执行显示结果操作)
3. 当进程关闭时，操作系统会回收进程中所占用的内存(即使某些线程由于闭包等原因造成内存泄漏。这些内存也会被回收)
4. 进程之间的内容互相隔离(这是为了保护操作系统进程互不干扰，例如某个站点进程可以访问另一个站点进程的内容，那么就会导致安全问题，想要进行进程间的通信的话，就要使用IPC进程通信机制)
* (不同主域名的站点会有不同的进程，例如打开百度会有一个进程id,打开淘宝网址又有一个进程id)

## 单进程浏览器时代
* 在2007年之前，也是Chrome浏览器发布之前，市面上的浏览器都是单进程的(也就是浏览器的所有功能模块都是运行在同一个进程里面，包括网络模块，站点模块，浏览器模块，GPU进程模块等)
* 这么多的功能模块都放在同一个进程里面，这就是一个很大的缺点，这么多的模块使得浏览器很难管理，而且模块，插件都挤在这个进程中，导致不流畅；并且由于所有的模块都放在这里，共享这个进程中的数据，也会导致不安全；并且这么多的模块都在一个进程中，只要有一个线程出现问题就会导致整个进程的崩溃，所以单进程浏览器不稳定(根据进程与线程的4个关系)
* 详细来说的话，单进程浏览器不安全，不稳定，不流畅的原因是:
1. 不稳定
* 我们已经知道，一个线程的错误会导致整个进程的崩溃，而在单进程浏览器时代，视频游戏这些功能都是通过插件来实现的，而插件又是很容易崩溃的，所以任何一个插件的崩溃都会引起整个浏览器的崩溃
* 除此之外，渲染引擎也是不稳定的，一些复杂的js代码就会引起渲染引擎模块的崩溃，导致整个浏览器的崩溃
2. 不流畅
* 单进程浏览器只有一个进程，而且线程也不多，仅仅是三种线程，分别是其他线程(可能很多个),网络线程，页面线程
* 需要注意的是`页面渲染，页面展现，js环境，插件都是运行在页面线程中的`
* 所以对于页面线程来说，同一时刻只能有一个模块运行，例如必须等待页面渲染完成再到页面展现，如果我们的JS代码使用了while(true)死循环，那么就会导致整个浏览器都卡顿失去响应
* 而内存泄漏也是一个不流畅的重要原因，因为此时还是单进程浏览器时代，所以关闭同站页面也会存在内存不能完成回收的情况，就会导致时间越久，内存泄漏越严重，浏览器越慢
3. 不安全
* 由于是单进程浏览器，所以每个线程都是共享该进程的数据，如果存在恶意插件，那么该恶意插件就可以获取该进程中的所有数据，例如网络进程，浏览器进程中的相关数据，可能会造成很严重的后果

## 多进程浏览器时代
* 2008年，谷歌发布了第一款多进程浏览器Chrome,这是一个多进程的浏览器，分为插件进程，渲染进程，浏览器主进程，进程之间通信使用IPC机制
* 渲染进程负责:解析，渲染，JS执行，合成网页图片；`注意:渲染进程运行在沙箱中，不能读写硬盘上的数据，不能获取操作系统的权限`
* 浏览器主进程负责:下载资源，管理IPC，显示渲染进程生成的图片
1. 解决不稳定问题
* 由于进程之间是相互隔离的，所以在多进程时代，一个页面或者插件的崩溃，仅仅会影响到当前渲染进程或者插件进程，不会导致整个页面的崩溃
2. 解决不流畅的问题
* 首先来看单线程时代的难题，js执行卡住了怎么办？在多进程时代，js执行是在渲染进程中执行的，即使js阻塞了渲染进程，也不会阻塞其他站点的渲染进程，也并不会影响浏览器进程和插件进程
* 然后再来看内存泄漏问题，当我们关闭站点的页面的时候，该站点的进程会被回收，包括内存泄漏的内存，所以这就解决了浏览器页面的内存泄漏问题
3. 解决安全问题
* 使用多进程架构的好处就在于可以使用沙箱(sandbox)，沙箱就相当于是操作系统给进程上了一把锁，`插件进程和渲染进程都被锁在沙箱中`。
* 在沙箱中的`程序可以运行，但是不可以在硬盘写入任何数据，也不能读取敏感位置(文档，桌面)的数据`。这样即使存在恶意程序被执行了，恶意程序也无法突破沙箱去写硬盘，读敏感数据。

## 目前的多进程浏览器架构
* 目前的Chrome浏览器包括:`一个浏览器进程，一个GPU进程，一个网络进程，多个渲染进程和多个插件进程`
* 浏览器进程:负责页面显示，子进程管理，用户交互，存储
* 渲染进程:核心任务是将html,css,js文件转换为网页，js引擎执行也是在这里的
* 网络进程:负责网络资源的加载
* 插件进程:负责插件的运行(主要是因为插件容易崩溃，为了不让插件的崩溃影响到其他进程，所以额外多一个插件进程)
* GPU进程:刚开始是为了3D CSS效果的绘制，后来UI页面全部都采用GPU来绘制
---
* 虽然多进程架构解决了不安全，不稳定，不流畅的问题，但是也带来了两个新的问题
1. 更高的资源占用
* 因为每个进程都有`公共基础结构的副本`(如js运行环境)，所以这意味着浏览器会占用更多的内存资源
2. 更复杂的体系架构
* 由于浏览器各个模块之间的`耦合性高，可拓展性差`，所以现在已经有点难适应新的需求了

## 未来面向服务的架构
* 为了解决上面两个问题，Chrome团队在16年提出了一种新的架构Service Oriented Architeture（SOA）面向服务的架构
1. 原来的每个模块会被重构成独立的服务，每个服务都可以在独立的进程中运行，访问服务必须使用接口，使用IPC进行通信(减少了公共基础结构副本的内存资源)
2. 原来的进程变为浏览器主进程，插件进程，渲染进程，再加上服务，一些耦合性较强的部分就变成服务，使得系统内聚性高，耦合性低，利于维护和更新


## 数据传输过程
* 互联网中的数据是通过数据包来传输，如果发送的数据很大，那么就会被拆分为多个数据包，那么数据包送达到应用程序需要解决三个问题:
1. 如何送达到目的主机
2. 主机如何把数据包送到应用程序
3. 数据包如何被`完整`的送达到应用程序
---
1. `IP(Internet Protocol)协议:把数据包送达到主机`
* 如果想把数据包从主机A发送到主机B，那么在数据包被传输之前，数据包之上会被附加上主机B的IP地址信息，同时为了让主机B能够回复信息给主机A，该数据包还需要附加上主机A的IP地址信息
2. `UDP(User Datagram Protocol)用户数据包协议把数据包发送给应用程序`、
* IP协议把数据包发送给主机B之后，主机B并不知道该把这个数据包发给音乐还是王者，所以这时候就需要UDP协议了。
* 端口号会被装进UDP头里面，UDP头再和原始数据合并组成新的UDP数据包，注意`UDP头里面除了目的端口号，还有源端口号(来源)`，UDP协议就会把数据包发送到目的端口所在的应用程序，应用程序回复信息的时候就往源端口号中发送数据包
---
* `注意，在主机A中制作数据包，首先在传输层加上UDP头(端口号)，再到网络层加上IP头(ip地址)；而到了主机B中，首先在网络层卸下IP头，再到传输层卸下UDP头`
---
* UDP协议存在两个问题
1. 数据包在传输过程中容易丢失(不会重发)
2. 大文件被拆分为多个数据包，这些数据包在不同的时间被发送出去，而`UDP协议不知道该如何组装这些数据包为完整的文件`。
---
* 为了解决这两个问题，我们使用了TCP(Transmission Control Protocol)数据传输控制协议
* TCP传输控制协议是一种面向连接的，可靠的，基于字节流的传输层通信协议
* TCP协议有以下两个特点
1. `发生数据包丢失的时候，TCP提供数据包重传机制`
2. `TCP协议引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件`
---
* 和UDP协议一样，TCP协议也需要端口号，但是除了端口号还需要一个排序号
* `TCP和IP协议配合的流程，首先在主机A中的传输层给数据包加上TCP头(端口号，排序号)，然后再在网络层给数据包加上IP头(IP地址)；等到了主机B的网络层就先拆解IP头，再到了传输层拆分TCP头`
---
* TCP建立连接使用三次握手
* TCP释放连接使用四次握手
1. 客户端首先发送一个FIN给服务器端，然后关闭自己到服务器端的连接,
2. 服务器端接收到客户端发送过来的FIN，然后发送一个ACK给客户端，告诉客户端自己收到了信息
3. 服务器端发送了ACK之后，再向客户端发送一个FIN,然后关闭服务器端到客户端的连接
4. 客户端接收到服务器端发送过来的FIN后，发回一个ACK报文确认，然后等待服务器关闭，服务器接收到客户端发来的ACK后关闭，然后客户端也关闭连接

## 大小写敏感
1. html,css对大小写不敏感，但是推荐用小写
2. js对大小写敏感，例如 a变量和A变量是不一样的，但是在html,css中是一个样的

## js脚本的加载方式
`没有defer,async属性时`
1. 浏览器一边下载html网页，一边解析
2. 在解析代码过程中发现script标签
3. `停止解析，把网页渲染控制权交给js引擎(js可以修改DOM,所以解析到js代码必须把网页渲染控制权交给js引擎，否则会导致线程竞赛问题)`
4. 如果js标签引入了外部脚本就并行下载外部脚本(`此时继续执行下面的代码，但是下载完毕之后就把控制权交给浏览器`)，否则就直接执行js脚本代码
5. 在script标签执行完毕之后，`把浏览器网页渲染控制权还给浏览器`，继续执行往下的html代码
---
* 对于多个script标签,如果这些标签都是下载外部文件，如
```
<script src="a.js"></script>
<script src="b.js"></script>
```
* `这几个文件会被并行下载,但是下载完成之后，执行顺序一定是a再到b。注意:下载这两个外部文件会造成阻塞，必须下载完成，浏览器才会继续进行页面渲染`
---
* 有defer属性的script标签
1. 浏览器一边下载html代码，一边解析
2. 解析到有defer属性的script标签的时候
3. `浏览器会继续往下解析html代码，同时并行下载defer属性的script标签的外部文件`
4. `在浏览器DOMContentLoaded事件触发之前(/html标签被读取之前)执行下载的外部defer属性脚本`
---
* 有async属性的script标签
1. 在解析的时候发现有async属性的script标签就并行下载script外部文件
2. `在下载async外部文件的时候继续解析网页；在下载完外部脚本之后，立马！执行外部脚本`
3. `在外部脚本执行完之后，继续解析下面的网页`

## 资源阻塞
1. 虽然按照传统浏览器来说，`img标签放在script标签之后`，应该要等到script代码下载并执行完成之后才会下载，但是`现代浏览器都是并行下载，但是还是会阻塞渲染`
2. `img标签放在script标签之前的时候，两者是并行下载`
3. `在css外部资源后面跟着script外部文件的时候,css就会阻塞js的下载`，因为css是样式啊，需要先渲染，这是浏览器的规则，`css样式必须在嵌入的js代码之前下载解析渲染完成`
4. `如果css外部资源在script外部文件后面，那么就是并行下载`，会先执行js代码
5. `iframe,img这些外部资源是异步加载，所以遇到普通的script标签，会先执行script标签内容(控制权在这里)，即使下载完了也不会中断script的解析`
* [参考](https://www.cnblogs.com/hgonlywj/p/4857151.html)
* [重要!!!](https://www.cnblogs.com/wuguanglin/p/JSAndImgLoadOrder.html)

## web页面生命周期
* 根据链接的例子:[例子](http://www.html-js.com/article/4585)
1. 浏览器的一般加载顺序为(同步的script):
```
script executed;readyState:interative;DOMContentLoaded;image onload;iframe onload ;readyState:complete ;window:onload
```
2. 可以看出来:`同步的script总是先于其他事件执行，而window.onload事件总是最后执行，image/iframe的执行顺序总是在中间，具体是不固定的`
---
3. 需要记住:`同步的script总是先执行的，比DOMContentLoaded先执行`
4. 在DOM准备就绪之后(`也就是页面文档完全载入并且解析完成之后，仅仅是页面文档,不包括外部资源`)，DOMContentLoaded事件在document上触发，`我们在DOMContentLoaded阶段使用js操作DOM节点,这也意味着程序执行从同步脚本阶段转移到事件驱动阶段`
5. 在js脚本执行完毕之后，可能还有异步外部资源(iframe,img)在载入过程中
6. 网页所有资源都`载入完毕，才开始执行document.onload事件`
---
* 如果再细分，我们可以使用document.readyState来表示文档的当前状态
1. loading:文档正在载入
2. interactive:在DOMContentLoaded`之前`触发，相差时间很短
3. complete:在document.onload`之前`触发，相差时间很短，此时也已经完全加载所有资源
---
1. 在onload页面加载完成之后还有其他生命周期
2. onpageshow事件在用户浏览网页的时候触发，跟onload事件很相似，但是onpageshow事件会触发多次，即使页面是从缓存中读取的也会触发，而Onload事件只在页面初次加载的时候触发，而Onpageshow事件的话，即使页面回退返回该页面也会触发，而Onload不会触发
3. beforeunload事件一般在页面卸载之前触发，常用于在关闭浏览器的时候弹出一个对话框，向用户询问是否确定关闭

## document.write()重写网页文档流
1. `window.onload=function(){	document.write('i am')	}`这样一段代码，无论之前网页内容是什么，此时在文档内容完全加载之后(文档已经关闭)再去执行docment.write()函数会自动调用window.open()函数创建一个新的文档流，写入新的内容，再通过浏览器显示，这样会覆盖原来的内容
2. 如果使用document.write()的时候，文档流并没有关闭，`那么即使调用document.write()方法也不会使用open()方法，因为文档流并没有关闭，所以也就不会覆盖了`
3. `document.close()	document.write('i am')这样也不会覆盖文档流`，因为document.close()只能关闭自己使用ocument.write()打开的文档流，不能关闭浏览器自己打开的文档流
4. 所以我们不能在异步文件中使用documen.write()函数，防止异步加载的时候，文档流已经关闭了，这样就会出现文档流覆盖的问题


## 浏览器手写动画最小时间间隔
* 建议最小时间间隔为0.1-0.3s
`多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms`

## 增量模型
* 把待开发的软件系统模块化，将每个模块作为一个增量组件，从而分批次地分析、设计、编码和测试这些增量组件

## 网卡
* 网卡工作在数据链路层，但也可以向下兼容物理层。实现数据的`封装与解封`，链路管理，编码与译码功能。

## 浏览器内核
1. webkit内核:`safari chorme`
2. trident内核:`IE,360,搜狗`
3. gecko内核:`firefox`

## Chrome浏览器支持#9497 这种四位的颜色表示，最后一位是透明度！

## 浏览器页面之间通信
1. 服务器方式就是通过提交表单更新服务器端的数据，然后另一个页面去获取更新后的数据就可以实现通信
2. 第一个页面通过localStorge.setItem()来实现存储在浏览器本地，另一个页面通过localStorge.getItem()来获取被存储的数据
3. 第一个页面把要存储的信息存储到cookie中，然后另一个页面通过setInterval来实现定时获取

## Cookie
1. `cookie一般是在服务器端生成，存放在浏览器端的，不过浏览器端也可以通过js代码设置cookie`
2. `cookie可以在跨域请求中被请求头携带`

## 浏览器页面之间的通信方式
1. 设置本地localStorage,通过setItem()存储，getItem()获取
2. `cookie配合Interval来实现定时获取cookie`
3. `sessionStorage不能实现浏览器之间的通信！！！因为sessionStorage是会话级别的，每个页面都是单独的sessionStorage`

## script中使用import
```
	<script type="module">
		import Browser from './js/browser.js'
		// 设置script type="module" 才能导入模块 import from 
		console.log(Browser.client.name+" "+Browser.client.version);
	</script>
```