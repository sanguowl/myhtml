## 1.说一下http和https
* http和https都是传输层的协议。
* http是在客户端和服务器端进行请求和应答的标准，即使https协议兴起，http协议依旧是最广泛的协议。http协议也被称为超文本传输协议，可以让服务器传输文本到浏览器端。
* 而https协议是在http协议基础上再增加一层SSL层的协议，SSL层也称为安全层，https协议是安全的，因为该协议传输的数据是加密的，而http传输的数据是不加密的，是明文。
* https协议的工作原理是:首先浏览器向服务器发送请求，该请求是https协议，服务器知道这是https协议，需要ssl层，因此需要传递自己的公钥给客户端；服务器端传递自己的公钥给浏览器，浏览器得到公钥之后，就用公钥去加密自己的密钥，并把加密好之后的密钥发送给服务器端，服务器就使用自己的私钥去解密密钥，得到浏览器的密钥，这个时候，浏览器和服务器之间就可以进行安全的请求和应答了。
* http和https协议的区别：
1. https协议比http协议安全，因为https协议使用了加密的方式，第三方获取，修改数据的成本增加了，而http没有加密；
2. http没有加密，但是https花费在加密上的时间较长，所以http更方便；
3. https协议虽然安全，但是ca证书需要钱的，所以http协议更便宜；
4. http协议使用的是80端口，https使用的是443端口；
---
* http协议的两个特点:
1. http协议是无连接的，`每次连接都只处理一个请求，在服务器端处理完客户端的请求之后就会断开连接，所以节省了传输时间`，之后即使是同样的资源也需要重新请求
2. 由于无连接特点的存在，http协议还存在无状态的特点，也就是每次连接都不会保存上一次连接的状态，例如登录状态，通俗来说就是`没有记忆能力`，而cookie就是对http记忆能力的补充


## 2. 三握手
  TCP连接的三握手其实就是客户端和服务器端互相确认彼此可以发送信息的过程；
  * 首先客户端发送第一条报文给服务器端，服务器端接收到客户端请求，也就表明服务器知道客户端可以发送信息给自己了，但是客户端还不知道，所以服务器还需要发送第二条报文给客户端，告诉客户端，你发的信息，我收到啦！
  * 客户端接收到服务器端发送过来的第二条报文之后，就知道自己发送的第一条报文成功了，但是这个时候，服务器还不知道自己发给客户端的报文有没有成功呢，所以客户端需要发送第三条报文给服务器端，告诉服务器，你发送成功啦~
  * 服务器接收到客户端发送给它的第三条报文，知道自己发给客户端的第二条报文成功啦，也就是自己可以正确发信息给客户端。
  这个时候，服务器和客户端都知道彼此可以正确的发送报文给对方了，这就是TCP连接的三握手。

## 3.get请求与post请求的区别
1. get请求是向服务器请求数据，而post请求是向服务器提交数据；换言之，get请求相当于向服务器中查询数据，post请求是对服务器中的数据进行增删改
2. get请求是不安全的，因为`参数会暴露在url`中一起发送给服务器；而post请求的通过请求体发送数据，不会暴露参数；也就是get请求的参数和header请求头信息都一次性通过url发送给服务器；
* 而post请求分为两次发送，第一次发送header请求头信息，当服务器返回100状态码之后再第二次发送数据
3. get请求对长度有限制，2k;而post对数据长度没有限制
4. get请求的数据会被缓存在浏览器中，而post请求的数据不会被缓存，所以提交登录表单之后刷新页面会弹出确认框


## 4. http状态码
* `1xx临时请求`,表示是临时请求并请求已经被接受，`需要继续处理`
* 100:请求者应该继续提出请求
* 101:请求者要求服务器切换协议，并且服务器已经确认并且准备切换协议
---
* `2xx表示已经成功处理了请求的代码`
* 200：服务器已经`成功处理(客户端已经接受到请求后的资源)`了请求，并且这一般指的是服务器提供了请求的网页
* 201：表示的是服务器已经接受到请求，并且`成功创建资源（资源还没发给客户端）`
* 202:服务器已经接受到了请求，但是还没有进行任何处理(`资源都还没创建`)
* 203:服务器成功处理了请求，但是客户端接收到的`返回的内容可能来自于其他服务器`(`这就是非授权信息`)
* 204:服务器成功处理了请求，但是`不返回任何实体内容`
* 205:服务器同样成功处理了请求，而且不返回任何实体内容，但是和204不同的在于，205状态码需要重置文档视图(`如填写密码表单失败后清孔密码要求重新输入`)
* 206::服务器已经成功处理了部分get请求，用于迅雷中的`断点续传功能`中，实现文件分段同时下载
---
* `3xx重定向,表示我们如果要继续完成请求的话需要进行进一步的操作`
* 300:被请求的资源有`一系列可供选择的回馈信息`,这些信息每一个都有自己特定的url地址，浏览器或者客户端可以选择地址进行重定向
* 301:被请求的资源已经`被永久迁移到一个新地址`了，将来任何对该资源的引用都应该使用本次响应返回的url地址之一
* 302:请求的资源现在临时从不同的url响应请求，但是这样的重定向是临时的,`客户端应该继续向原有地址发送请求`.
* 304:已经发送了一个带条件的get请求,并且请求已经被允许,`但是文档的内容并没有被改变`。
* 305:被请求的资源`必须经过代理才可以访问`。
---
* `4xx 客户端错误`
* 400:一:`语义有误`，不被服务器所识别，需要修改;二:`请求参数有误`
* 401:当前请求需要`用户验证`。该`响应`必须包含一个适用于被请求资源的` WWW-Authenticate 信息头`用以`询问用户信息`。客户端可以重复`提交`一个包含恰当的` Authorization 头信息`的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着`服务器验证已经拒绝了那些证书`.
* 403:服务器已经接受到请求，但是`拒绝执行`，而且和401不同，`身份验证不起作用`。403错误和404错误不同，`403错误希望说清楚拒绝执行的原因`。
* 404:请求失败，`没有在服务器发现所需的资源`(但是不想说清楚为何拒绝执行请求的时候也可以用)。而且这个失败是永久的还是暂时的不确定.404这个状态码被广泛应用于当服务器`不想揭示到底为何请求被拒绝`或者没有其他适合的响应可用的情况下。
* 405:`请求行中指定的请求方法不能用于请求相应的资源`。
* 406:请求的资源的`内容特性不满足`请求头的要求。
* 407:和401状态码一样需要进行`身份验证`，不同的是需要在`代理服务器`中进行。
---
* `5xx服务端错误:服务器在处理请求的过程中有错误或者异常情况发生，也有可能是服务器意识到当前的软硬件资源无法完成对请求的处理`
* 500:服务器遇到了从未预料到的错误，导致它无法完成请求
* 501:服务器不支持当前请求所需要的某个功能
* 503:由于临时的`服务器维护或者过载`，服务器无法处理当前请求，这个状态是临时的，会给出预计时间Retry-After ，如果没有给出，那么可以发送500状态码
* 
* 小应用:通过 XMLHttpRequest更新以下元素，即通过div显示状态  `<div id="statusCode"></div>`
*`var myDiv = document.getElementById ("statusCode"); myDiv.innerHTML = req.status;`

## 5.跨域
* 要理解跨域，先要了解一下“同源策略”。所谓同源是指，`域名，协议，端口`相同
* `在同源策略下，在某个服务器下的页面是无法获取到该服务器以外的数据的`。例如我们在自己的网站通过ajax去获取豆瓣上的接口数据，但是会报错，因为域名不一致
* `但<img>的src（获取图片），<link>的href（获取css），<script>的src（获取javascript）这三个都不符合同源策略，但它们可以跨域获取数据,不受同源策略的约束,所以我们平时才不会察觉到同源策略的约束`
* 但是我们在实际开发中，有时候需要直接通过get,post请求来获取服务器接口数据，那就不可避免会碰到跨域问题了，例如我们需要在js中使用this.$axios.get('http://www.baidu.com').then()获取接口数据，然后再绑定到元素中，这时候使用jsonp这种避开跨域的方式就不管用了，我用过的解决方法是在自己的服务器端设置允许跨域访问的HTTP头部，也就是使用CORS解决跨域方案


## 6.javascript中实现跨域的方式总结
1. 第一种方式：jsonp请求；jsonp的原理是利用`<script>`标签的跨域特性，可以不受限制地从其他域中加载资源，类似的标签还有`<img>`
2. 第二种方式：`document.domain`这种方式用在`主域名相同子域名不同`的跨域访问中
* 主域名:`有两个或以上的字母组成，中间有点号隔开，但是只有一个1点号，如 badu,net`;子域名:`主域名之下的子域名，会有多个点号 blog.badu.net`
3. 第三种方式：window.name；window的name属性有个特征：在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。
4. 第四种方式：window.postMessage；window.postMessages是html5中实现跨域访问的一种新方式，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源。
5. 第五种方式：CORS(cross origin resource sharing)跨域资源共享；CORS背后的基本思想，就是使用`自定义的HTTP头部`让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是应该失败。
* [CORS](http://www.ruanyifeng.com/blog/2016/04/cors.html)
6. 第六种方式：Web Sockets；web sockets原理：在JS创建了`web socket`之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为`web sockt协议`。websoket是基于tcp协议的

## 7.HTTP协议
* HTTP协议是建立在TCP连接基础之上的。HTTP协议是一种允许浏览器向服务器获取资源的协议，是web的基础.HTTP协议也是浏览器使用最广的协议

`浏览器端发起HTTP请求流程`
1. 构建请求
* 首先浏览器构建`请求行`信息，然后准备发起网络请求。请求行如:`GET /index.html HTTP1.1`

2. 查找缓存
* 在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中`浏览器缓存是一种在本地保存的资源副本`，可以供下次请求直接使用。
* 当浏览器发送请求行中请求的资源已经在浏览器缓存中有副本了，那么浏览器会拦截请求，返回资源副本，并且直接结束请求，好处有:
+ 缓解服务器端的压力，提升性能
+ 对于网站来说，缓存是实现快速资源加载的重要一步（有时直接用缓存就可以了不需要发起网络请求）
3. 准备IP地址和端口
* `HTTP是应用层协议，用来封装文本信息然后发给传输层`，`TCP协议是传输层协议，在传输层给数据套上TCP头(端口和序列号)`，`然后再在网络层使用IP网际协议给数据再套上IP头(IP地址)`，然后就可以发送到网络了
* 所以说，HTTP请求的第一步就是和服务器建立起TCP连接，而TCP连接需要IP协议提供的IP地址和TCP协议提供的端口，然后就可以和服务器建立TCP连接了
* 而IP地址和端口号从哪里得到？
* `我们发起HTTP请求的时候会有一个URL，URL中就包含了Ip地址和端口号`
---
* 如果URL中没有没有指明IP地址，那么我们会使用`DNS域名系统(进行域名解析时使用udp协议)`来映射获取对应的IP地址，另外DNS还有缓存服务(映射过的地址会被保存)
* 端口号的话，HTTP请求默认为80端口，HTTPS请求默认为443端口

4. 等待TCP队列
* 获得了IP地址和端口号，那么可以建立TCP连接了？
* 不，在Chrome中有一个机制，同一个域名最多同时有6个TCP链接，如果在同一个域名下同时有10个请求发生，那么剩下的4个请求会进入排队等待状态，甚至进行中的请求完成

5. 建立TCP连接
* 在排队等待结束之后，就可以通过三握手建立TCP连接了

6. 发送HTTP请求
* 一旦建立了TCP连接，浏览器就可以和服务器进行通信了
---
* 首先浏览器会向服务器发送请求行，请求行包括请求方式，请求URI，HTTP版本协议
* 发送请求行之后，还会通过请求头发送其他信息，例如cookie,浏览器版本等
* 如果请求方式是post,最后还会通过请求体发送数据给服务器

`服务器端处理HTTP请求流程`
1. 返回请求
* 一旦服务器处理完请求，就可以给浏览器返回数据了
* 首先服务器会返回响应行，包括HTTP协议版本，状态码
* 然后会给浏览器发送响应头，响应头包含了服务器自身的一些信息，比如返回的数据格式，服务端要在客户端保存的cookie信息
* 最后就可以发送响应体的数据了，通常来说，`响应体就包含了HTML的实际内容`。

2. 断开连接
* 一般来说，一旦服务器端向客户端返回了请求数据，那么它就要关闭TCP连接。但是如果`浏览器或者服务器`在其头信息中加入了`Connection:keep-alive`
* 那么`TCP连接在发送后依旧保持打开状态`，这样浏览器就可以通过同一个TCP连接发送请求
* `保持TCP连接可以省去下次请求时需要建立连接的时候，提升资源加载速度`，如：`如果一个web页面中的图片都来自同一个web站点，那么加了keep-alive就可以持久化连接，可以复用连接来请求其他资源，而不需要再重新建立新的TCP连接`

3. 重定向
* 例子:`在网址中输入geekbang.org,然后回车，结果返回的响应头中的location为https://www.geekbang.org/，状态码为301，表示永久被重定向到该网址了`
* `但是301这种永久重定向需要在服务器端设置重定向地址，否则不会发生重定向的`

## 8.为什么很多站点第二次打开速度很快?
* `因为DNS缓存和页面资源缓存`
* 页面资源缓存:在服务器返回HTTP响应头给浏览器的时候，浏览器是通过响应头中的`Cache-Control字段来设置是否缓存该资源的`,通常来说，我们会为这个资源设置一个缓存时长，而这个时长是通过`Cache-Control中的Max-age参数来设置的`
* 例如:`Cache-Control:Max-age=2000`；而`Cache-Control:Max-age=0`则是每次都强制刷新，不要校验是否有缓存
* 这就意味着，在该缓存资源还未过期的情况下，如果再次请求该资源，会直接返回缓存中的资源给浏览器；如果缓存过期了，浏览器会继续发起网络请求，并且在HTTP请求头上带上`If-None-Match字段`
* 在服务器收到请求头之后，会根据`If-None-Match`来判断请求的资源是否有更新
* 如果没有更新，那么会返回`304状态码，告诉客户端，这个缓存可以继续使用，因为没有更新，所以这次就不发送数据给你了`
* 如果有更新，那么就会发送新的数据给客户端

## 9.用户登录状态是怎么保持的?
1. 用户打开登录页面，在登录框里填入用户名和密码，然后点击确定按钮。点击按钮会触发页面脚本生成用户登录信息，然后调用post方法提交用户登录信息给服务器
2. 服务器接收到浏览器提交的信息之后，查询后台，验证用户登录信息是否正确，如果正确的话会生成一段表示用户身份的字符串，并把字符串写到响应头的set-cookie字段里
* 如下所示，然后把响应头发送到浏览器
* `Set-Cookie:UID=3431uad`
3. 浏览器在接收到服务器的响应头之后，开始解析响应头，如果遇到响应头中有`Set-Cookie`字段，那么浏览器会把这个字段保存到本地，例如`UID=3241uad`保存到本地
4. 当用户再次访问该站点的页面，浏览器会发起http请求，但是在发起http请求之前，浏览器会读取之前保存的cookie数据，并把数据写进请求头里的cookie字段里，然后浏览器再把请求头发给服务器
* `Cookie:UID=3424uad`
5. 服务器在收到HTTP请求头数据之后，会查找请求头里的Cookie字段信息，当查找到UID=314uad的信息时，服务器查询后台，并判断用户是否是已登录状态，然后生成包含该用户信息的页面数据，把数据发送给浏览器
6. 浏览器在接收到含有该用户信息的数据之后，就可以显示该用户登录时的页面了


## 请求头字段
1. referer:设置`前一个页面的地址`，并且前一个页面中的连接指向当前地址，也就是通过a页面来到当前b页面，那么referer就是a的地址
`https://www.so.com/s?q=%E8%AF%B7%E6%B1%82%E5%A4%B4%E7%BC%BA%E5%B0%91Etag%E5%AD%97%E6%AE%B5&src=srp&fr=hao_360so_suggest_b&psid=88dab29c42845b3d3b4eefebb69f6b92`
2. origin:`指示最初最初最初！！！的请求来源`，`在跨域的时候，get/post都会显示origin；同域的时候post显示origin,get不显示origin`,`如果浏览器不清楚请求的最初来源，那么就不显示origin字段`，`origin字段比referer更安全一点吧`
* Origin: http://www.example-social-network.com
[参考](http://blog.sina.com.cn/s/blog_625f850801015tik.html)
3. range:设置请求实体的字节数范围
`Range: bytes=500-999`
4. X-Requested-With: `标记ajax请求`，大部分js请求都会设置为XMLHttpRequest
5. Accept:表示接受的内容的数据类型
6. Accept-Charset:设置接受的字符编码
7. Accept-Encoding:表示接受的编码格式
8. Connection:主要用来设置`keep-alive表示不断开tcp连接`，但是还有一个选项是`Upgrate`,还有一个字段是`close，表示客户端发给服务端要断开tcp连接，最好有，这是规范`
9. Content-Type:设置`请求体的MIME类型`,`MIME类型就是用一个字符串(application/xxx)来指代一个请求得到的文件类型(flv,jar,css等等)`
* 如: Content-Type:application/javascript
* [参考](https://www.cnblogs.com/tjudzj/p/6528008.html)
10. Date:消息发送的时间，不一定和现在的时间一致
11. Host:`表示服务器的域名和端口号，如果是默认端口号就不用设置`，响应头不会发送Host字段
12. Upgrade:请求服务器升级协议(看101状态码)
13. Cache-Control:告诉缓存机制对这个对象的缓存时间，`max-age=0表示每次都强制刷新，max-age=3600则表示一个小时后这个缓存才过期`

## MIME类型
1. `text/html表示返回的文本需要被解析为HTML格式`
2. `text/plain表示返回的文本不需要被解析，就是纯文本`
3. `application/json表示返回的是json格式数据`

## http缓存头
1. Expires(`缓存的最后有效时间，超过该时间，缓存失效`):格式为Fri,24,Dec 2020 04：24:01 GMT
2. Last-Modified/If-Modified:`一般服务端都会在响应头返回一个Last-Modified字段，告诉浏览器这个页面的最后修改时间`
3. Etag/If-None-Match:`用于验证缓存有效性`

## http各个版本
1. http/0.9
* http协议是基于tcp/ip协议的应用层协议，不涉及数据包的传输，主要用于规定客户端和服务器端的通信格式，默认使用80端口
* 最早的版本就是91年发布的0.9版本，只有一个命令get:`get /index.html`
* 而且该版本只能回应html格式的字符串
2. http/1.0
* 96年发布了1.0版本，除了get命令还引入post,head命令；
* 另外Http请求的格式也变了，除了数据部分，每次请求都必须有`头信息`
* 还新增了`状态码，缓存，权限`
* 由于每次的tcp连接只能发送一个请求，然后就关闭，所以在1.0版本引入了`Connection:keep-alive来要求服务器不要关闭tcp连接`
3. http/1.1
* 发布时间只比1.0版本晚了半年，最大的变化就是引入了`持久连接,也即是tcp连接默认不关闭，不用声明Connection:keep-alive,当服务器或者客户端发现对方一段时间没有请求就主动关闭连接，但是规范是客户端在最后一个请求发送Connection:close明确要求服务器关闭连接`
* 并且，`对于同一个域名，多数浏览器可以持久化6个连接`
* 新增了`PUT,OPTIONS,DELETE方法，还新增了Host字段`
4. http/2
* 支持在未经客户端许可的情况下，`主动向客户端推送内容`
* http/2的`头信息和数据体都是二进制`，而http/1.x的头信息是文本(ASCLL编码)，数据体可以是文本也可以是二进制
* 支持多路复用，因为有流id,所以可以`通过一个http请求实现多个http请求传输`变成了可能
[参考](https://blog.csdn.net/zq_king/article/details/80319847)

## UDP协议和TCP协议的区别
1. TCP协议保证数据正确性，保证数据顺序；UDP不保证数据顺序，UDP可能丢包
2. UDP是无连接的，而TCP是面向连接的，也就是TCP连接之前都需要进行三握手，断开连接进行四挥手
3. TCP基于字节流模式，而UDP是基于数据报模式
4. TCP需要的系统资源较多，而UDP需要的系统资源较少
5. `每一条TCP连接都是点到点的，而UDP连接支持一对一，一对多，多对多的交互通信`

## MAC地址
1. MAC地址成为局域网地址/以太网地址/物理地址，是用来确定网上设备位置的地址，形象的说，就是身份证，具有唯一性
2. `作用:MAC地址专注于数据链路层，将一个数据帧从一个节点传送到相同链路的另一个节点，MAC地址用于在网络中唯一标识一个网卡，如果一台设备有多个网卡则每个网卡都有唯一的MAC地址`
3. `长度:MAC地址长度是48比特(字节),由16进制的数字组成，分为前24位和后24位`
* `前24位是组织唯一标识符，是IEEE机构给厂家分配的代码`
* `后24位是厂家自己分配的代码，称为拓展标识符`

## MAC地址和IP地址的联系
1. `对应关系:在一个稳定的网络中，IP地址和MAC地址总是成对出现的，如果一台计算机要和另一台计算机通信，那么需要配置计算机的IP地址，然后计算机的MAC地址是网卡出厂时设定的，所以IP地址和MAC地址形成了对应关系`
2. `ARP地址解析协议(负责IP地址和MAC地址的映射):IP地址负责计算机的网络层地址，网络层设备有路由器;MAC地址负责计算机的数据链路层地址，如交换机`
3. 举例`192.168.1.1   f4-ec-38-33-28-44`

## MAC地址和IP地址的区别
1. `IP地址虽然是唯一的，但是容易更改，但是MAC地址不容易更改，除非换网卡`
2. `长度不同:IP地址的长度是32位，MAC地址的长度是48位`
3. `寻址层不同:IP地址应用于网络层，MAC地址应用于数据链路层`
4. `分配依据不同:IP地址的分配是基于网络拓扑，MAC地址的分配是基于厂家`

## 信道上可传送信号的最高频率和最低频率之差成为信道带宽
## 信号传输速率单位是 b/s

## http是应用层协议，udp是传输层协议，ip是网络层的协议，都是无连接协议

## OSI网络协议体系
1. 七层`应用层 表示层 会话层 传输层 网络层 数据链路层 物理层`
1. 七层`应用层(HTTP) 表示层 会话层 传输层(TCP,UDP) 网络层(IP协议 路由器) 数据链路层(网卡 MAC地址 ARP解析协议) 物理层`

## cn域名是中国的意思，是顶级域名
1. 正确的域名是 edu.cn, youyou.com ,net.jp
2. `cn.edu错误！顶级域名应该在最后`